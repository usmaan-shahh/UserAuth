The Zod Middleware validate's incoming request data using Zod schemas before the request reaches the controller.

jwt.verify(token, SECRET) // 1. Verify token signature and expiration 

Accept: application/json   	         “Send me JSON”
Content-Type: application/json 	     “I am sending JSON to you”


req.accepts("html"); Browser wants HTML
req.accepts("json"); API Clients want JSON


In Express, next() normally means:
"Go to the next middleware or route."

But when you pass an error inside it: next(error);
send this error object to the global error handler."

origin: (origin, callback) => { ... } This Fn is provided by the CORS library internally.

Without credentials: true, Authorization headers, Sessions, Cookies  will NOT be sent or received. This completely breaks any authentication system.

// Global error handler function signature: It has 4 parameters: (error, request, response, next) and ALWAYS placed at the bottom of server.js, after all routes:

preflight requests: A preflight request is a request sent automatically by the browser, without any sensitive data, to check:
                    “Is this origin allowed to make this type of request?”

Correct Middleware Stack Execution Order
1.) CORS: Should be first because it handles preflight(OPTIONS) request
2.) app.use(express.json()); This middleware parses JSON data from the request body and makes them available in req.body.
3.) app.use(cookieParser()); This middleware parses cookies sent by the browser and makes them available in req.cookies.
4.) Log Every Request using logger  to log file
5.) Security middleware like Rate limiting
6.) Routes
7.) 404 Handler (after routes, before error handler)
8.) Error Handler - LAST (catches all errors)

On Every incomming request CORS middleware is triggered and CORS calls your origin function:

A controller is responsible only for HTTP concerns, not business logic.
It handles:
1.) Request & Response objects: Extracts data from req and sends data via res
2.) Status codes are set by CONTROLLERS (HTTP layer), never by services
3.) Cookie operation's (HTTP-specific storage): Stores refresh token in HTTP cookie, Reads cookies from requests and Clears cookies on logout

 Service's Handle Business Logic like (Can This User Register) (What Happens After Login) and is completely independent of HTTP.
 Throws domain-specific errors that we have defined in error's.js
 A service does NOT talk to the database directly. Instead, it communicates with the database  through repositories or models
 Hashes Password's
 Generate Tokens


When both client and server  has different origins.

CORS allow's client to read response from server.

CORS configuration defines security rules that control which origins (websites) are allowed to read a server’s response in the browser.

Both the browser (client) and the server must explicitly allow credentials for cookies to be exchanged.

CSRF(Cross-Site Request Forgery) prevent's unwanted actions by requiring a CSRF token along with the cookies in each state-changing request.