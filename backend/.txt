The Zod Middleware validate's incoming request data using Zod schemas before the request reaches the controller.

jwt.verify(token, SECRET) // 1. Verify token signature and expiration 

Accept: application/json   	         “Send me JSON”
Content-Type: application/json 	     “I am sending JSON to you”


req.accepts("html"); Browser wants HTML
req.accepts("json"); API Clients want JSON


In Express, next() normally means:
"Go to the next middleware or route."

But when you pass an error inside it: next(error);
send this error object to the global error handler."

origin: (origin, callback) => { ... } This Fn is provided by the CORS library internally.

Without credentials: true, Authorization headers, Sessions, Cookies  will NOT be sent or received. This completely breaks any authentication system.

// Global error handler function signature: It has 4 parameters: (error, request, response, next) and ALWAYS placed at the bottom of server.js, after all routes:

preflight requests: A preflight request is a request sent automatically by the browser, without any sensitive data, to check:
                    “Is this origin allowed to make this type of request?”

Correct Middleware Stack Execution Order
1.) CORS: Should be first because it handles preflight(OPTIONS) request
2.) app.use(express.json()); This middleware parses JSON data from the request body and makes them available in req.body.
3.) app.use(cookieParser()); This middleware parses cookies sent by the browser and makes them available in req.cookies.
4.) Log Every Request using logger  to log file
5.) Security middleware like Rate limiting
6.) Routes
7.) 404 Handler (after routes, before error handler)
8.) Error Handler - LAST (catches all errors)

On Every incomming request CORS middleware is triggered and CORS calls your origin function:
A controller is responsible only for HTTP concerns, not business logic.
It handles:
1.) Request & Response objects: Extracts data from req and sends data via res
2.) HTTP status codes: 200 OK, 201 Created, 400 Bad Request, 401 Unauthorized, etc.
3.) Cookies (HTTP-specific storage): Setting, reading, and clearing cookies (e.g.,refresh tokens)
4.) HTTP headers: Content type, authorization headers, caching rules, CORS headers
5.) Request data parsing: req.body, req.query, req.params
6.) Response formatting: JSON, HTML, plain text, redirects

 Service's Handle Business logic like (Can This User Register) (What Happens After Login) and is completely independent of HTTP.
 Throws domain-specific errors that we have defined in error's.js
 A service does NOT talk to the database directly. Instead, it communicates with the database  through repositories or models
 Hashes Password's
 Generate Tokens
 
CORS Configuration: Security rules that control which websites can access your API.
For cross-origin requests, both the browser (client) and the server must explicitly allow credentials for cookies to be exchanged.
