The Zod Middleware validate's incoming request data using Zod schemas before the request reaches the controller.

jwt.verify(token, SECRET) // 1. Verify token signature and expiration 

Accept: application/json   	         “Send me JSON”
Content-Type: application/json 	     “I am sending JSON to you”


req.accepts("html"); Browser wants HTML
req.accepts("json"); API Clients want JSON


In Express, next() normally means:
"Go to the next middleware or route."

But when you pass an error inside it: next(error);
send this error object to the global error handler."

origin: (origin, callback) => { ... } This Fn is provided by the CORS library internally.

Without credentials: true, Authorization headers, Sessions, Cookies  will NOT be sent or received. This completely breaks any authentication system.

// Global error handler function signature: It has 4 parameters: (error, request, response, next) and ALWAYS placed at the bottom of server.js, after all routes:

preflight requests: A preflight request is a request sent automatically by the browser, without any sensitive data, to check:
                    “Is this origin allowed to make this type of request?”

Correct Middleware Stack Execution Order
1.) CORS: Should be first because it handles preflight(OPTIONS) request
2.) app.use(express.json()); This middleware parses JSON data from the request body and makes them available in req.body.
3.) app.use(cookieParser()); This middleware parses cookies sent by the browser and makes them available in req.cookies.
4.) Log Every Request using logger  to log file
5.) Security middleware like Rate limiting
6.) Routes
7.) 404 Handler (after routes, before error handler)
8.) Error Handler - LAST (catches all errors)


On Every incomming request CORS middleware is triggered and CORS calls your origin function

A controller is responsible only for HTTP concerns, not business logic.
It handles:
1.) Request & Response objects: Extracts data from req and sends data via res
2.) HTTP status codes: 200 OK, 201 Created, 400 Bad Request, 401 Unauthorized, etc.
3.) Cookies (HTTP-specific storage): Setting, reading, and clearing cookies (e.g.,refresh tokens)
4.) HTTP headers: Content type, authorization headers, caching rules, CORS headers
5.) Request data parsing: req.body, req.query, req.params
6.) Response formatting: JSON, HTML, plain text, redirects


Throws domain-specific errors
Calls database layer but does not know how HTTP works
Password hashing
Token generation
Permission checks
handle's Business logic like
1.) “Can this user register?”
2.) “What happens after login?”
completely independent of HTTP.